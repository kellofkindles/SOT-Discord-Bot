"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const request = require("request");
const GitHubLinks = require("./github-links");
const errors = require("./errors");
const querystring_1 = require("querystring");
const CLIENT_ID = '0000000048093EE3';
const SCOPE = 'service::user.auth.xboxlive.com::MBI_SSL';
const RESPONSE_TYPE = 'token';
const DEFAULT_RELYING_PARTY = 'http://xboxlive.com';
const USER_AGENT = [
    'Mozilla/5.0 (XboxReplay; XboxLiveAuth/2.0)',
    'AppleWebKit/537.36 (KHTML, like Gecko)',
    'Chrome/71.0.3578.98 Safari/537.36'
].join(' ');
const BASE_HEADERS = {
    Accept: 'application/json; charset=utf-8',
    'Accept-Language': 'en-US',
    'User-Agent': USER_AGENT
};
const LIVE_ENDPOINTS = {
    authorize: 'https://login.live.com/oauth20_authorize.srf',
    redirect: 'https://login.live.com/oauth20_desktop.srf'
};
const XBOX_LIVE_ENDPOINTS = {
    userAuthenticate: 'https://user.auth.xboxlive.com/user/authenticate',
    XSTSAuthorize: 'https://xsts.auth.xboxlive.com/xsts/authorize'
};
const _getMatchForIndex = (entry, regex, index = 0) => {
    const match = entry.match(regex);
    if (match === null)
        return null;
    if (match[index] === void 0)
        return null;
    return match[index];
};
const _requiresIdentityConfirmation = (body) => {
    const m1 = _getMatchForIndex(body, /id=\"fmHF\" action=\"(.*?)\"/, 1);
    const m2 = _getMatchForIndex(m1 || '', /identity\/confirm/, 0);
    return m2 !== null;
};
const _preAuth = () => new Promise((resolve, reject) => {
    const jar = request.jar();
    const authorizeQuery = {
        client_id: CLIENT_ID,
        redirect_uri: LIVE_ENDPOINTS.redirect,
        response_type: RESPONSE_TYPE,
        scope: SCOPE,
        display: 'touch',
        locale: 'en'
    };
    request({
        uri: LIVE_ENDPOINTS.authorize +
            '?' +
            unescape(querystring_1.stringify(authorizeQuery)),
        gzip: true,
        headers: BASE_HEADERS,
        jar
    }, (err, _, body) => {
        if (err)
            return reject(errors.internal(err.message));
        const matches = {
            PPFT: _getMatchForIndex(body, /sFTTag:'.*value=\"(.*)\"\/>'/, 1),
            urlPost: _getMatchForIndex(body, /urlPost:'([A-Za-z0-9:\?_\-\.&\\/=]+)/, 1)
        };
        if (matches.PPFT === null) {
            return reject(errors.matchError(`Could not match "PPFT" parameter, please fill an issue on ${GitHubLinks.createIssue}`));
        }
        else if (matches.urlPost === null) {
            return reject(errors.matchError(`Could not match "urlPost" parameter, please fill an issue on ${GitHubLinks.createIssue}`));
        }
        return resolve({
            jar,
            matches: {
                PPFT: matches.PPFT,
                urlPost: matches.urlPost
            }
        });
    });
});
const _logUser = (preAuthResponse, credentials) => new Promise((resolve, reject) => {
    const jar = request.jar();
    request({
        uri: preAuthResponse.matches.urlPost,
        method: 'POST',
        gzip: true,
        followRedirect: false,
        headers: Object.assign({}, BASE_HEADERS, { 'Content-Type': 'application/x-www-form-urlencoded', Cookie: preAuthResponse.jar.getCookieString(LIVE_ENDPOINTS.authorize) }),
        body: querystring_1.stringify({
            login: credentials.email,
            loginfmt: credentials.email,
            passwd: credentials.password,
            PPFT: preAuthResponse.matches.PPFT
        }),
        jar
    }, (err, response, body) => {
        if (err)
            return reject(errors.internal(err.message));
        const { location } = response.headers;
        if (location === void 0) {
            return _requiresIdentityConfirmation(body)
                ? reject(errors.unauthorizedActivity())
                : reject(errors.invalidCredentials());
        }
        const matches = {
            accessToken: _getMatchForIndex(location, /access_token=(.+?)&/, 1),
            refreshToken: _getMatchForIndex(location, /refresh_token=(.+?)&/, 1)
        };
        if (matches.accessToken === null) {
            return reject(errors.matchError(`Could not match "access_token" parameter, please fill an issue on ${GitHubLinks.createIssue}`));
        }
        return resolve({
            accessToken: matches.accessToken,
            refreshToken: matches.refreshToken
        });
    });
});
exports.exchangeRpsTicketForUserToken = (RpsTicket) => new Promise((resolve, reject) => {
    request({
        uri: XBOX_LIVE_ENDPOINTS.userAuthenticate,
        method: 'POST',
        gzip: true,
        headers: Object.assign({}, BASE_HEADERS, { 'x-xbl-contract-version': 0 }),
        json: {
            RelyingParty: 'http://auth.xboxlive.com',
            TokenType: 'JWT',
            Properties: {
                AuthMethod: 'RPS',
                SiteName: 'user.auth.xboxlive.com',
                RpsTicket
            }
        }
    }, (err, response, body) => {
        if (err)
            return reject(errors.internal(err.message));
        else if (response.statusCode !== 200)
            return reject(errors.exchangeFailure('Could not exchange specified "RpsTicket"'));
        return resolve(body.Token);
    });
});
exports.exchangeAccessTokenForUserToken = (accessToken) => exports.exchangeRpsTicketForUserToken(accessToken);
exports.exchangeUserTokenForXSTSIdentity = (userToken, XSTSRelyingParty = DEFAULT_RELYING_PARTY) => new Promise((resolve, reject) => {
    request({
        uri: XBOX_LIVE_ENDPOINTS.XSTSAuthorize,
        method: 'POST',
        gzip: true,
        headers: Object.assign({}, BASE_HEADERS, { 'x-xbl-contract-version': 0 }),
        json: {
            RelyingParty: XSTSRelyingParty,
            TokenType: 'JWT',
            Properties: {
                UserTokens: [userToken],
                SandboxId: 'RETAIL'
            }
        }
    }, (err, response, body) => {
        if (err)
            return reject(errors.internal(err.message));
        else if (response.statusCode !== 200) {
            const isDefaultRelyingParty = XSTSRelyingParty === DEFAULT_RELYING_PARTY;
            const computedErrorMessage = [
                'Could not exchange "userToken", please',
                `refer to ${GitHubLinks.seeUserTokenIssue}`
            ];
            if (isDefaultRelyingParty === false)
                computedErrorMessage.splice(1, 0, 'double check the specified "XSTSRelyingParty" or');
            return reject(errors.exchangeFailure(computedErrorMessage.join(' ')));
        }
        return resolve({
            userXUID: body.DisplayClaims.xui[0].xid || null,
            userHash: String(body.DisplayClaims.xui[0].uhs),
            XSTSToken: String(body.Token),
            expiresOn: String(body.NotAfter)
        });
    });
});
exports.authenticate = (email, password, options = {}) => __awaiter(this, void 0, void 0, function* () {
    const preAuthResponse = yield _preAuth();
    const logUser = yield _logUser(preAuthResponse, { email, password });
    const userToken = yield exports.exchangeRpsTicketForUserToken(logUser.accessToken);
    return exports.exchangeUserTokenForXSTSIdentity(userToken, options.XSTSRelyingParty);
});
